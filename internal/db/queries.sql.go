// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompany = `-- name: CreateCompany :exec
INSERT INTO companies (id, created_on, modified_on, vat, name, address, phone)
VALUES ($1, NOW(), NOW(), $2, $3, $4, $5)
`

type CreateCompanyParams struct {
	ID      []byte
	Vat     pgtype.Text
	Name    pgtype.Text
	Address pgtype.Text
	Phone   pgtype.Int8
}

// Create a new company
func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) error {
	_, err := q.db.Exec(ctx, createCompany,
		arg.ID,
		arg.Vat,
		arg.Name,
		arg.Address,
		arg.Phone,
	)
	return err
}

const createInventory = `-- name: CreateInventory :exec
INSERT INTO inventory (material_id, quantity, date_last_modified)
VALUES ($1, $2, NOW())
`

type CreateInventoryParams struct {
	MaterialID []byte
	Quantity   pgtype.Int4
}

// Create a new inventory entry
func (q *Queries) CreateInventory(ctx context.Context, arg CreateInventoryParams) error {
	_, err := q.db.Exec(ctx, createInventory, arg.MaterialID, arg.Quantity)
	return err
}

const createMaterial = `-- name: CreateMaterial :exec
INSERT INTO materials (id, picture, description, name, supplier_id, unit_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateMaterialParams struct {
	ID          []byte
	Picture     pgtype.Text
	Description pgtype.Text
	Name        pgtype.Text
	SupplierID  []byte
	UnitID      []byte
}

// Create a new material
func (q *Queries) CreateMaterial(ctx context.Context, arg CreateMaterialParams) error {
	_, err := q.db.Exec(ctx, createMaterial,
		arg.ID,
		arg.Picture,
		arg.Description,
		arg.Name,
		arg.SupplierID,
		arg.UnitID,
	)
	return err
}

const createRecipe = `-- name: CreateRecipe :exec
INSERT INTO recipes (id, product_name, description)
VALUES ($1, $2, $3)
`

type CreateRecipeParams struct {
	ID          []byte
	ProductName pgtype.Text
	Description pgtype.Text
}

// Create a new recipe
func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) error {
	_, err := q.db.Exec(ctx, createRecipe, arg.ID, arg.ProductName, arg.Description)
	return err
}

const createRecipeMaterial = `-- name: CreateRecipeMaterial :exec
INSERT INTO recipe_materials (recipe_id, material_id, unit_id)
VALUES ($1, $2, $3)
`

type CreateRecipeMaterialParams struct {
	RecipeID   []byte
	MaterialID []byte
	UnitID     []byte
}

// Create a new recipe material entry
func (q *Queries) CreateRecipeMaterial(ctx context.Context, arg CreateRecipeMaterialParams) error {
	_, err := q.db.Exec(ctx, createRecipeMaterial, arg.RecipeID, arg.MaterialID, arg.UnitID)
	return err
}

const createSupplier = `-- name: CreateSupplier :exec
INSERT INTO suppliers (id, name, email, phone)
VALUES ($1, $2, $3, $4)
`

type CreateSupplierParams struct {
	ID    []byte
	Name  pgtype.Text
	Email pgtype.Text
	Phone pgtype.Int4
}

// Create a new supplier
func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) error {
	_, err := q.db.Exec(ctx, createSupplier,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Phone,
	)
	return err
}

const createTransactionHistory = `-- name: CreateTransactionHistory :exec
INSERT INTO transaction_history (id, date, details, type, price, document_path, destination, material_id)
VALUES ($1, NOW(), $2, $3, $4, $5, $6, $6)
`

type CreateTransactionHistoryParams struct {
	ID           []byte
	Details      pgtype.Text
	Type         pgtype.Text
	Price        pgtype.Numeric
	DocumentPath pgtype.Text
	Destination  pgtype.Text
}

// Create a new transaction history entry
func (q *Queries) CreateTransactionHistory(ctx context.Context, arg CreateTransactionHistoryParams) error {
	_, err := q.db.Exec(ctx, createTransactionHistory,
		arg.ID,
		arg.Details,
		arg.Type,
		arg.Price,
		arg.DocumentPath,
		arg.Destination,
	)
	return err
}

const createUnit = `-- name: CreateUnit :exec
INSERT INTO units (id, unit_string)
VALUES ($1, $2)
`

type CreateUnitParams struct {
	ID         []byte
	UnitString pgtype.Text
}

// Create a new unit
func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) error {
	_, err := q.db.Exec(ctx, createUnit, arg.ID, arg.UnitString)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (email, created_on, modified_on, password_hash, username, company_id)
VALUES ($1, NOW(), NOW(), $2, $3, $4)
`

type CreateUserParams struct {
	Email        string
	PasswordHash []byte
	Username     pgtype.Text
	CompanyID    []byte
}

// Create a new user
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.Username,
		arg.CompanyID,
	)
	return err
}

const deleteCompany = `-- name: DeleteCompany :exec
DELETE FROM companies WHERE id = $1
`

// Delete a company
func (q *Queries) DeleteCompany(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteCompany, id)
	return err
}

const deleteInventory = `-- name: DeleteInventory :exec
DELETE FROM inventory WHERE material_id = $1
`

// Delete an inventory entry
func (q *Queries) DeleteInventory(ctx context.Context, materialID []byte) error {
	_, err := q.db.Exec(ctx, deleteInventory, materialID)
	return err
}

const deleteMaterial = `-- name: DeleteMaterial :exec
DELETE FROM materials WHERE id = $1
`

// Delete a material
func (q *Queries) DeleteMaterial(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteMaterial, id)
	return err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes WHERE id = $1
`

// Delete a recipe
func (q *Queries) DeleteRecipe(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteRecipe, id)
	return err
}

const deleteRecipeMaterial = `-- name: DeleteRecipeMaterial :exec
DELETE FROM recipe_materials WHERE recipe_id = $1 AND material_id = $2
`

type DeleteRecipeMaterialParams struct {
	RecipeID   []byte
	MaterialID []byte
}

// Delete a recipe material entry
func (q *Queries) DeleteRecipeMaterial(ctx context.Context, arg DeleteRecipeMaterialParams) error {
	_, err := q.db.Exec(ctx, deleteRecipeMaterial, arg.RecipeID, arg.MaterialID)
	return err
}

const deleteSupplier = `-- name: DeleteSupplier :exec
DELETE FROM suppliers WHERE id = $1
`

// Delete a supplier
func (q *Queries) DeleteSupplier(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteSupplier, id)
	return err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM units WHERE id = $1
`

// Delete a unit
func (q *Queries) DeleteUnit(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteUnit, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE email = $1
`

// Delete a user
func (q *Queries) DeleteUser(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUser, email)
	return err
}

const getAllCompanies = `-- name: GetAllCompanies :many

SELECT id, created_on, modified_on, vat, name, address, phone FROM companies
`

// Companies CRUD Operations
// Get all companies
func (q *Queries) GetAllCompanies(ctx context.Context) ([]Company, error) {
	rows, err := q.db.Query(ctx, getAllCompanies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.CreatedOn,
			&i.ModifiedOn,
			&i.Vat,
			&i.Name,
			&i.Address,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllInventory = `-- name: GetAllInventory :many

SELECT material_id, quantity, date_last_modified FROM inventory
`

// Inventory CRUD Operations
// Get all inventory
func (q *Queries) GetAllInventory(ctx context.Context) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, getAllInventory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inventory
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(&i.MaterialID, &i.Quantity, &i.DateLastModified); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMaterials = `-- name: GetAllMaterials :many

SELECT id, picture, description, name, supplier_id, unit_id FROM materials
`

// Materials CRUD Operations
// Get all materials
func (q *Queries) GetAllMaterials(ctx context.Context) ([]Material, error) {
	rows, err := q.db.Query(ctx, getAllMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.Picture,
			&i.Description,
			&i.Name,
			&i.SupplierID,
			&i.UnitID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRecipeMaterials = `-- name: GetAllRecipeMaterials :many

SELECT recipe_id, material_id, unit_id FROM recipe_materials
`

// RecipeMaterials CRUD Operations
// Get all recipe materials
func (q *Queries) GetAllRecipeMaterials(ctx context.Context) ([]RecipeMaterial, error) {
	rows, err := q.db.Query(ctx, getAllRecipeMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeMaterial
	for rows.Next() {
		var i RecipeMaterial
		if err := rows.Scan(&i.RecipeID, &i.MaterialID, &i.UnitID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRecipes = `-- name: GetAllRecipes :many

SELECT id, product_name, description FROM recipes
`

// Recipes CRUD Operations
// Get all recipes
func (q *Queries) GetAllRecipes(ctx context.Context) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, getAllRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(&i.ID, &i.ProductName, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSuppliers = `-- name: GetAllSuppliers :many

SELECT id, name, email, phone FROM suppliers
`

// Suppliers CRUD Operations
// Get all suppliers
func (q *Queries) GetAllSuppliers(ctx context.Context) ([]Supplier, error) {
	rows, err := q.db.Query(ctx, getAllSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTransactionHistory = `-- name: GetAllTransactionHistory :many

SELECT id, date, details, type, price, document_path, destination, material_id FROM transaction_history
`

// TransactionHistory CRUD Operations
// Get all transaction history
func (q *Queries) GetAllTransactionHistory(ctx context.Context) ([]TransactionHistory, error) {
	rows, err := q.db.Query(ctx, getAllTransactionHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransactionHistory
	for rows.Next() {
		var i TransactionHistory
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Details,
			&i.Type,
			&i.Price,
			&i.DocumentPath,
			&i.Destination,
			&i.MaterialID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnits = `-- name: GetAllUnits :many

SELECT id, unit_string FROM units
`

// Units CRUD Operations
// Get all units
func (q *Queries) GetAllUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getAllUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(&i.ID, &i.UnitString); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many

SELECT email, created_on, modified_on, password_hash, username, company_id FROM users
`

// Users CRUD Operations
// Get all users
func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Email,
			&i.CreatedOn,
			&i.ModifiedOn,
			&i.PasswordHash,
			&i.Username,
			&i.CompanyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyById = `-- name: GetCompanyById :one
SELECT id, created_on, modified_on, vat, name, address, phone FROM companies WHERE id = $1
`

// Get company by id
func (q *Queries) GetCompanyById(ctx context.Context, id []byte) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyById, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.CreatedOn,
		&i.ModifiedOn,
		&i.Vat,
		&i.Name,
		&i.Address,
		&i.Phone,
	)
	return i, err
}

const getInventoryByMaterialId = `-- name: GetInventoryByMaterialId :one
SELECT material_id, quantity, date_last_modified FROM inventory WHERE material_id = $1
`

// Get inventory by material_id
func (q *Queries) GetInventoryByMaterialId(ctx context.Context, materialID []byte) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventoryByMaterialId, materialID)
	var i Inventory
	err := row.Scan(&i.MaterialID, &i.Quantity, &i.DateLastModified)
	return i, err
}

const getMaterialById = `-- name: GetMaterialById :one
SELECT id, picture, description, name, supplier_id, unit_id FROM materials WHERE id = $1
`

// Get material by id
func (q *Queries) GetMaterialById(ctx context.Context, id []byte) (Material, error) {
	row := q.db.QueryRow(ctx, getMaterialById, id)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.Picture,
		&i.Description,
		&i.Name,
		&i.SupplierID,
		&i.UnitID,
	)
	return i, err
}

const getRecipeById = `-- name: GetRecipeById :one
SELECT id, product_name, description FROM recipes WHERE id = $1
`

// Get recipe by id
func (q *Queries) GetRecipeById(ctx context.Context, id []byte) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeById, id)
	var i Recipe
	err := row.Scan(&i.ID, &i.ProductName, &i.Description)
	return i, err
}

const getRecipeMaterialsById = `-- name: GetRecipeMaterialsById :one
SELECT recipe_id, material_id, unit_id FROM recipe_materials WHERE recipe_id = $1 AND material_id = $2
`

type GetRecipeMaterialsByIdParams struct {
	RecipeID   []byte
	MaterialID []byte
}

// Get recipe materials by recipe_id and material_id
func (q *Queries) GetRecipeMaterialsById(ctx context.Context, arg GetRecipeMaterialsByIdParams) (RecipeMaterial, error) {
	row := q.db.QueryRow(ctx, getRecipeMaterialsById, arg.RecipeID, arg.MaterialID)
	var i RecipeMaterial
	err := row.Scan(&i.RecipeID, &i.MaterialID, &i.UnitID)
	return i, err
}

const getRecipesByMaterial = `-- name: GetRecipesByMaterial :many
SELECT r.id, r.product_name, r.description
FROM recipes r
JOIN recipe_materials rm ON r.id = rm.recipe_id
WHERE rm.material_id = $1
`

// Get all recipes with a certain material
func (q *Queries) GetRecipesByMaterial(ctx context.Context, materialID []byte) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, getRecipesByMaterial, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(&i.ID, &i.ProductName, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierById = `-- name: GetSupplierById :one
SELECT id, name, email, phone FROM suppliers WHERE id = $1
`

// Get supplier by id
func (q *Queries) GetSupplierById(ctx context.Context, id []byte) (Supplier, error) {
	row := q.db.QueryRow(ctx, getSupplierById, id)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
	)
	return i, err
}

const getTransactionHistoryById = `-- name: GetTransactionHistoryById :one
SELECT id, date, details, type, price, document_path, destination, material_id FROM transaction_history WHERE id = $1
`

// Get transaction history by id
func (q *Queries) GetTransactionHistoryById(ctx context.Context, id []byte) (TransactionHistory, error) {
	row := q.db.QueryRow(ctx, getTransactionHistoryById, id)
	var i TransactionHistory
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Details,
		&i.Type,
		&i.Price,
		&i.DocumentPath,
		&i.Destination,
		&i.MaterialID,
	)
	return i, err
}

const getUnitById = `-- name: GetUnitById :one
SELECT id, unit_string FROM units WHERE id = $1
`

// Get unit by id
func (q *Queries) GetUnitById(ctx context.Context, id []byte) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitById, id)
	var i Unit
	err := row.Scan(&i.ID, &i.UnitString)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT email, created_on, modified_on, password_hash, username, company_id FROM users WHERE email = $1
`

// Get user by email
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.Email,
		&i.CreatedOn,
		&i.ModifiedOn,
		&i.PasswordHash,
		&i.Username,
		&i.CompanyID,
	)
	return i, err
}

const updateCompany = `-- name: UpdateCompany :exec
UPDATE companies
SET modified_on = NOW(), vat = $1, name = $2, address = $3, phone = $4
WHERE id = $5
`

type UpdateCompanyParams struct {
	Vat     pgtype.Text
	Name    pgtype.Text
	Address pgtype.Text
	Phone   pgtype.Int8
	ID      []byte
}

// Update an existing company
func (q *Queries) UpdateCompany(ctx context.Context, arg UpdateCompanyParams) error {
	_, err := q.db.Exec(ctx, updateCompany,
		arg.Vat,
		arg.Name,
		arg.Address,
		arg.Phone,
		arg.ID,
	)
	return err
}

const updateInventory = `-- name: UpdateInventory :exec
UPDATE inventory
SET quantity = $2, date_last_modified = NOW()
WHERE material_id = $1
`

type UpdateInventoryParams struct {
	MaterialID []byte
	Quantity   pgtype.Int4
}

// Update an existing inventory entry
func (q *Queries) UpdateInventory(ctx context.Context, arg UpdateInventoryParams) error {
	_, err := q.db.Exec(ctx, updateInventory, arg.MaterialID, arg.Quantity)
	return err
}

const updateMaterial = `-- name: UpdateMaterial :exec
UPDATE materials
SET picture = $2, description = $3, name = $4, supplier_id = $5, unit_id = $6
WHERE id = $1
`

type UpdateMaterialParams struct {
	ID          []byte
	Picture     pgtype.Text
	Description pgtype.Text
	Name        pgtype.Text
	SupplierID  []byte
	UnitID      []byte
}

// Update an existing material
func (q *Queries) UpdateMaterial(ctx context.Context, arg UpdateMaterialParams) error {
	_, err := q.db.Exec(ctx, updateMaterial,
		arg.ID,
		arg.Picture,
		arg.Description,
		arg.Name,
		arg.SupplierID,
		arg.UnitID,
	)
	return err
}

const updateRecipe = `-- name: UpdateRecipe :exec
UPDATE recipes
SET product_name = $2, description = $3
WHERE id = $1
`

type UpdateRecipeParams struct {
	ID          []byte
	ProductName pgtype.Text
	Description pgtype.Text
}

// Update an existing recipe
func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe, arg.ID, arg.ProductName, arg.Description)
	return err
}

const updateRecipeMaterial = `-- name: UpdateRecipeMaterial :exec
UPDATE recipe_materials
SET unit_id = $3
WHERE recipe_id = $1 AND material_id = $2
`

type UpdateRecipeMaterialParams struct {
	RecipeID   []byte
	MaterialID []byte
	UnitID     []byte
}

// Update an existing recipe material entry
func (q *Queries) UpdateRecipeMaterial(ctx context.Context, arg UpdateRecipeMaterialParams) error {
	_, err := q.db.Exec(ctx, updateRecipeMaterial, arg.RecipeID, arg.MaterialID, arg.UnitID)
	return err
}

const updateSupplier = `-- name: UpdateSupplier :exec
UPDATE suppliers
SET name = $2, email = $3, phone = $4
WHERE id = $1
`

type UpdateSupplierParams struct {
	ID    []byte
	Name  pgtype.Text
	Email pgtype.Text
	Phone pgtype.Int4
}

// Update an existing supplier
func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) error {
	_, err := q.db.Exec(ctx, updateSupplier,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Phone,
	)
	return err
}

const updateUnit = `-- name: UpdateUnit :exec
UPDATE units
SET unit_string = $2
WHERE id = $1
`

type UpdateUnitParams struct {
	ID         []byte
	UnitString pgtype.Text
}

// Update an existing unit
func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) error {
	_, err := q.db.Exec(ctx, updateUnit, arg.ID, arg.UnitString)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET modified_on = NOW(), password_hash = $2, username = $3, company_id = $4
WHERE email = $1
`

type UpdateUserParams struct {
	Email        string
	PasswordHash []byte
	Username     pgtype.Text
	CompanyID    []byte
}

// Update an existing user
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Email,
		arg.PasswordHash,
		arg.Username,
		arg.CompanyID,
	)
	return err
}
